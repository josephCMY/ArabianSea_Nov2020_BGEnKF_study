












module da_module_couple_uv_ad

   

use da_module_couple_uv, only: da_calc_mu_uv

contains

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4165) - 21 sep 2011 20:54
!
!  Differentiation of da_couple_uv in reverse (adjoint) mode:
!   gradient     of useful results: u v mu
!   with respect to varying inputs: u v mu
!   RW status of diff variables: u:in-out v:in-out mu:incr
SUBROUTINE DA_COUPLE_UV_B(u, ub, v, vb, mu, mub0, mub, msfu, msfv, ids, &
&  ide, jds, jde, kds, kde)
  IMPLICIT NONE
! if (trace_use) call da_trace_exit("da_couple_uv")  
  INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde
  REAL, INTENT(INOUT) :: u(ids:ide+1, jds:jde, kds:kde)
  REAL, INTENT(INOUT) :: ub(ids:ide+1, jds:jde, kds:kde)
  REAL, INTENT(INOUT) :: v(ids:ide, jds:jde+1, kds:kde)
  REAL, INTENT(INOUT) :: vb(ids:ide, jds:jde+1, kds:kde)
  REAL, INTENT(IN) :: msfu(ids:ide+1, jds:jde)
  REAL, INTENT(IN) :: msfv(ids:ide, jds:jde+1)
  REAL, INTENT(IN) :: mu(ids:ide, jds:jde)
  REAL :: mub0(ids:ide, jds:jde)
  REAL, INTENT(IN) :: mub(ids:ide, jds:jde)
  REAL, ALLOCATABLE :: muu(:, :), muv(:, :)
  REAL, ALLOCATABLE :: muub(:, :), muvb(:, :)
  INTEGER :: arg1
  ALLOCATE(muub(ids:ide+1, jds:jde))
! update_bc
! if (trace_use) call da_trace_entry("da_couple_uv")  
  ALLOCATE(muu(ids:ide+1, jds:jde))
  ALLOCATE(muvb(ids:ide, jds:jde+1))
  ALLOCATE(muv(ids:ide, jds:jde+1))
! couple variables u, v
  CALL DA_CALC_MU_UV(mu, mub, muu, muv, ids, ide, jds, jde)
  arg1 = jde + 1
  CALL DA_COUPLE_B(muv, muvb, v, vb, msfv, ids, ide, jds, arg1, kds, kde&
&            )
  arg1 = ide + 1
  CALL DA_COUPLE_B(muu, muub, u, ub, msfu, ids, arg1, jds, jde, kds, kde&
&            )
  CALL DA_CALC_MU_UV_B(mu, mub0, mub, muu, muub, muv, muvb, ids, ide, &
&                 jds, jde)
  muub = 0.0
  muvb = 0.0
  DEALLOCATE(muv)
  DEALLOCATE(muvb)
  DEALLOCATE(muu)
  DEALLOCATE(muub)
END SUBROUTINE DA_COUPLE_UV_B
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4165) - 21 sep 2011 20:54
!
!  Differentiation of da_calc_mu_uv in reverse (adjoint) mode:
!   gradient     of useful results: muu muv mu
!   with respect to varying inputs: mu
SUBROUTINE DA_CALC_MU_UV_B(mu, mub0, mub, muu, muub, muv, muvb, ids, ide&
&  , jds, jde)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: ids, ide, jds, jde
  REAL, DIMENSION(ids:ide, jds:jde), INTENT(IN) :: mu, mub
  REAL, DIMENSION(ids:ide, jds:jde) :: mub0
  REAL, DIMENSION(ids:ide + 1, jds:jde) :: muu
  REAL, DIMENSION(ids:ide+1, jds:jde) :: muub
  REAL, DIMENSION(ids:ide, jds:jde + 1) :: muv
  REAL, DIMENSION(ids:ide, jds:jde+1) :: muvb
  REAL, DIMENSION(ids - 1:ide + 1, jds - 1:jde + 1) :: mut
  REAL, DIMENSION(ids-1:ide+1, jds-1:jde+1) :: mutb
  INTEGER :: i, j
  mutb = 0.0
  DO j=jde+1,jds,-1
    DO i=ide,ids,-1
      mutb(i, j) = mutb(i, j) + 0.5*muvb(i, j)
      mutb(i, j-1) = mutb(i, j-1) + 0.5*muvb(i, j)
      muvb(i, j) = 0.0
    END DO
  END DO
  DO j=jde,jds,-1
    DO i=ide+1,ids,-1
      mutb(i, j) = mutb(i, j) + 0.5*muub(i, j)
      mutb(i-1, j) = mutb(i-1, j) + 0.5*muub(i, j)
      muub(i, j) = 0.0
    END DO
  END DO
  DO i=ide+1,ids-1,-1
    mutb(i, jde) = mutb(i, jde) + mutb(i, jde+1)
    mutb(i, jde+1) = 0.0
    mutb(i, jds) = mutb(i, jds) + mutb(i, jds-1)
    mutb(i, jds-1) = 0.0
  END DO
  DO j=jde,jds,-1
    mutb(ide, j) = mutb(ide, j) + mutb(ide+1, j)
    mutb(ide+1, j) = 0.0
    mutb(ids, j) = mutb(ids, j) + mutb(ids-1, j)
    mutb(ids-1, j) = 0.0
    DO i=ide,ids,-1
      mub0(i, j) = mub0(i, j) + mutb(i, j)
      mutb(i, j) = 0.0
    END DO
  END DO
END SUBROUTINE DA_CALC_MU_UV_B
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4165) - 21 sep 2011 20:54
!
!  Differentiation of da_couple in reverse (adjoint) mode:
!   gradient     of useful results: field
!   with respect to varying inputs: field mut
SUBROUTINE DA_COUPLE_B(mut, mutb, field, fieldb, msf, ids, ide, jds, jde&
&  , kds, kde)
  IMPLICIT NONE
! if (trace_use) call da_trace_exit("da_couple")
  INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde
  REAL, INTENT(IN) :: mut(ids:ide, jds:jde)
  REAL :: mutb(ids:ide, jds:jde)
  REAL, INTENT(IN) :: msf(ids:ide, jds:jde)
  REAL, INTENT(INOUT) :: field(ids:ide, jds:jde, kds:kde)
  REAL, INTENT(INOUT) :: fieldb(ids:ide, jds:jde, kds:kde)
  INTEGER :: i, j, k
  mutb = 0.0
  DO j=jde,jds,-1
    DO k=kde,kds,-1
      DO i=ide,ids,-1
        mutb(i, j) = mutb(i, j) + field(i, j, k)*fieldb(i, j, k)/msf(i, &
&          j)
        fieldb(i, j, k) = mut(i, j)*fieldb(i, j, k)/msf(i, j)
      END DO
    END DO
  END DO
END SUBROUTINE DA_COUPLE_B

end module da_module_couple_uv_ad
